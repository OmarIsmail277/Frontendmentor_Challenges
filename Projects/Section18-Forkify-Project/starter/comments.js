// lecture 293
/*
So we will have one big module here
for all the controllers.
Then one big file for the entire model.
So for all the models basically.
So for the recipe, for search, for bookmarks
and all of that but for the views,
we will have one module for each of the different views.
And you'll understand why that makes sense
as we keep developing our application.
And probably the first reason that comes to mind
is that the views are simply much bigger.
And so we don't want a file, which like 500 lines of code.
We could, of course, also split up the model
and the controller and probably many people would do that
but I don't want to have to mess with a lot
of files here in this project.
That would just make it very confusing for you to follow.
*/
/*
So rendering the spinner, of course,
has nothing to do with the business logic
but really, it is only presentation logic
and so this one will eventually go
into the view.
*/
/*
And then here getting the ID,
this is also not business logic.
This is actually more about the application logic itself.
So about making the application work.
*/
/*
So this function here is not going to return anything.
All it will do is to change our state object.
*/
/*
So this function here is not going to return anything.
All it will do is to change our state object.

So this big state object,
which will then contain the recipe
and into which the controller
will then grab and take the recipe out of there.
*/
/*
This loadRecipe function
is an async function and therefore,
it is going to return a promise. Remember?

And so therefore, here we have to await that promise
before we can move on in the next step here
in the execution of this async function.

And so you see, this is exactly the situation
of one async function calling another async function
that we already studied in one of the previous sections.
Remember that?

And so again, it is really, really important
to keep in mind that an async function
will return a promise
that we then need to handle
whenever we call that async function.
At least, if we want to get some result out of it
or if we kind of want to stop the execution
in the function that is calling the other async function.

All right?
So again, really important to understand the mechanics
of what is happening here.
*/

/* 
todo 1- Call the render method on the bookmarksView in the controller and pass bookmarks data to it
? bookmarksView.render(model.state.bookmarks);
todo 2) The render method will check if the passed data is ok (bookmarks) then assign that data to the data property of the bookmarksView instance
?this._data = data;
then call its generateMarkup() method on in it.
>> calling the bookmarksView._generateMarkup() method
?const markup = this._generateMarkup();
todo 3) Inside of bookmarksView's _generateMarkup() method, we map over the data property(array of bookmarked recipes), and render a preview for each element by calling the previewView.render() method
? _generateMarkup() {
  return this._data
    .map(bookmark => previewView.render(bookmark, false))
    .join('');
}
    ----------------------------------------------------------------
    So, we want to render bookmarks in our application. The Bookmarks component basically consists of a list of the Preview components, right? So, to render the Bookmarks component, we need our Bookmarks component to render possibly multiple Preview components.

So, what happens here:

1) We call the render() method on the bookmarksView instance in the controller, and pass bookmarks data to it

bookmarksView.render(model.state.bookmarks);
2) The render() method will check if the data is ok (the if statement), then assign that data to the _data property of the bookmarksView instance, and then call its _generateMarkup() method

render(data, render = true) {
 
  // checking data
  if (!data || (Array.isArray(data) && data.length === 0))
    return this.renderError();
 
  // assigning to bookmarksView._data
  this._data = data
 
  // calling the bookmarksView._generateMarkup() method
  const markup = this._generateMarkup();
3) Inside of bookmarksView's _generateMarkup() method, we map over the _data property (array of recipes), and render a preview for each element by calling the previewView.render() method

_generateMarkup() {
  return this._data
    .map(bookmark => previewView.render(bookmark, false))
    .join('');
}
But, this time we pass false as a second argument. This is important because it will change how the render() method behaves — instead of inserting the markup to the DOM, it will only return that markup. That's why we have this line in our render() method

if (!render) return markup;
If render (the second parameter) is false, simply return the markup generated by the previewView._generateMarkup() method; don't insert it to the DOM yet because we want to insert the whole Bookmarks component that contains Previews for each bookmarked recipe.

4) The markup for each Preview is collected in an array (because the map() method collects results of its callback into an array

.map(bookmark => previewView.render(bookmark, false))
and then, this array of Preview markups is joined to create one big string, and this string is returned to the render() method called, at the beginning, on the bookmarksView instance

return this._data
    .map(bookmark => previewView.render(bookmark, false))
    .join('');
5) So, now, we're back to the initial call of the render() method — bookmarksView.render()

render(data, render = true) {
  if (!data || (Array.isArray(data) && data.length === 0))
    return this.renderError();
 
  this._data = data;
  const markup = this._generateMarkup();
 
  if (!render) return markup;
 
  this._clear();
  this._parentElement.insertAdjacentHTML('afterbegin', markup);
}
The render parameter was true (the default value), so the if statement is skipped

if (!render) return markup;
and, it goes straight to inserting the Bookmark's markup to the DOM

this._clear();
this._parentElement.insertAdjacentHTML('afterbegin', markup);
Note that this Bookmark markup also contains the markup for all Previews (because it was returned from the previewView.render() method, and joined inside of the bookmarkView._generateMarkup() method).

That's it. Let me know if you have any questions or if something is not clear.

*/
